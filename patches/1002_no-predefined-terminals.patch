Description: use BOOST_SPIRIT_NO_PREDEFINED_TERMINALS
 Backport of upstream patch to reduce memory usage during compilation
Origin: https://github.com/mapnik/mapnik/pull/2134
Reviewed-by: Jérémy Lal <kapouer@melix.org>
Last-Update: 2014-04-03

--- a/SConstruct
+++ b/SConstruct
@@ -1619,6 +1619,11 @@
         debug_defines = ['-DDEBUG', '-DMAPNIK_DEBUG']
         ndebug_defines = ['-DNDEBUG']
 
+        # faster compile
+        # http://www.boost.org/doc/libs/1_47_0/libs/spirit/doc/html/spirit/what_s_new/spirit_2_5.html#spirit.what_s_new.spirit_2_5.breaking_changes
+        env.Append(CPPDEFINES = '-DBOOST_SPIRIT_NO_PREDEFINED_TERMINALS=1')
+        env.Append(CPPDEFINES = '-DBOOST_PHOENIX_NO_PREDEFINED_TERMINALS=1')
+
         # Enable logging in debug mode (always) and release mode (when specified)
         if env['DEFAULT_LOG_SEVERITY']:
             if env['DEFAULT_LOG_SEVERITY'] not in severities:
--- a/src/box2d.cpp
+++ b/src/box2d.cpp
@@ -400,10 +400,12 @@
         // needing to link to libmapnik
         std::string::const_iterator str_beg = item.begin();
         std::string::const_iterator str_end = item.end();
+        boost::spirit::qi::double_type double_;
+        boost::spirit::ascii::space_type space;
         bool r = boost::spirit::qi::phrase_parse(str_beg,
                                                  str_end,
-                                                 boost::spirit::qi::double_,
-                                                 boost::spirit::ascii::space,
+                                                 double_,
+                                                 space,
                                                  d[i]);
         if (!(r && (str_beg == str_end)))
         {
--- a/src/color_factory.cpp
+++ b/src/color_factory.cpp
@@ -30,10 +30,6 @@
 #include <boost/format.hpp>
 #include <boost/version.hpp>
 
-// stl
-#include <sstream>
-
-
 namespace mapnik {
 
 color parse_color(std::string const& str)
@@ -46,19 +42,18 @@
                   css_color_grammar<std::string::const_iterator> const& g)
 {
     color c;
-
     std::string::const_iterator first = str.begin();
     std::string::const_iterator last =  str.end();
-    
+    boost::spirit::ascii::space_type space;
     // boost 1.41 -> 1.44 compatibility, to be removed in mapnik 2.1 (dane)
 #if BOOST_VERSION >= 104500
     bool result = boost::spirit::qi::phrase_parse(first, last, g,
-                                                  boost::spirit::ascii::space,
+                                                  space,
                                                   c);
 #else
     mapnik::css css_;
     bool result = boost::spirit::qi::phrase_parse(first, last, g,
-                                                  boost::spirit::ascii::space, 
+                                                  space, 
                                                   css_);
     c.set_red(css_.r);
     c.set_green(css_.g);
@@ -68,9 +63,13 @@
 #endif
 
     if (result && (first == last))
+    {
         return c;
+    }
     else
+    {
         throw config_error( "Failed to parse color: \"" + str + "\"" );
+    }
 }
 
 }
--- a/src/conversions.cpp
+++ b/src/conversions.cpp
@@ -58,12 +58,12 @@
 
 using namespace boost::spirit;
 
-BOOST_SPIRIT_AUTO(qi, INTEGER, qi::int_)
+BOOST_SPIRIT_AUTO(qi, INTEGER, qi::int_type())
 #ifdef BIGINT
-BOOST_SPIRIT_AUTO(qi, LONGLONG, qi::long_long)
+BOOST_SPIRIT_AUTO(qi, LONGLONG, qi::long_long_type())
 #endif
-BOOST_SPIRIT_AUTO(qi, FLOAT, qi::float_)
-BOOST_SPIRIT_AUTO(qi, DOUBLE, qi::double_)
+BOOST_SPIRIT_AUTO(qi, FLOAT, qi::float_type())
+BOOST_SPIRIT_AUTO(qi, DOUBLE, qi::double_type())
 
 struct bool_symbols : qi::symbols<char,bool>
 {
@@ -82,75 +82,85 @@
 
 bool string2bool(const char * iter, const char * end, bool & result)
 {
-    using boost::spirit::qi::no_case;
-    bool r = qi::phrase_parse(iter,end, no_case[bool_symbols()] ,ascii::space,result);
+    boost::spirit::qi::no_case_type no_case;
+    ascii::space_type space;
+    bool r = qi::phrase_parse(iter,end,no_case[bool_symbols()],space,result);
     return r && (iter == end);
 }
 
 bool string2bool(std::string const& value, bool & result)
 {
-    using boost::spirit::qi::no_case;
+    boost::spirit::qi::no_case_type no_case;
+    ascii::space_type space;
     std::string::const_iterator str_beg = value.begin();
     std::string::const_iterator str_end = value.end();
-    bool r = qi::phrase_parse(str_beg,str_end,no_case[bool_symbols()],ascii::space,result);
+    bool r = qi::phrase_parse(str_beg,str_end,no_case[bool_symbols()],space,result);
     return r && (str_beg == str_end);
 }
 
 bool string2int(const char * iter, const char * end, int & result)
 {
-    bool r = qi::phrase_parse(iter,end,INTEGER,ascii::space,result);
+    ascii::space_type space;
+    bool r = qi::phrase_parse(iter,end,INTEGER,space,result);
     return r && (iter == end);
 }
 
 bool string2int(std::string const& value, int & result)
 {
+    ascii::space_type space;
     std::string::const_iterator str_beg = value.begin();
     std::string::const_iterator str_end = value.end();
-    bool r = qi::phrase_parse(str_beg,str_end,INTEGER,ascii::space,result);
+    bool r = qi::phrase_parse(str_beg,str_end,INTEGER,space,result);
     return r && (str_beg == str_end);
 }
 
 #ifdef BIGINT
 bool string2int(const char * iter, const char * end, mapnik::value_integer & result)
 {
-    bool r = qi::phrase_parse(iter,end,LONGLONG,ascii::space,result);
+    ascii::space_type space;
+    bool r = qi::phrase_parse(iter,end,LONGLONG,space,result);
     return r && (iter == end);
 }
 
 bool string2int(std::string const& value, mapnik::value_integer & result)
 {
+    ascii::space_type space;
     std::string::const_iterator str_beg = value.begin();
     std::string::const_iterator str_end = value.end();
-    bool r = qi::phrase_parse(str_beg,str_end,LONGLONG,ascii::space,result);
+    bool r = qi::phrase_parse(str_beg,str_end,LONGLONG,space,result);
     return r && (str_beg == str_end);
 }
 #endif
 
 bool string2double(std::string const& value, double & result)
 {
+    ascii::space_type space;
     std::string::const_iterator str_beg = value.begin();
     std::string::const_iterator str_end = value.end();
-    bool r = qi::phrase_parse(str_beg,str_end,DOUBLE,ascii::space,result);
+    bool r = qi::phrase_parse(str_beg,str_end,DOUBLE,space,result);
     return r && (str_beg == str_end);
 }
 
 bool string2double(const char * iter, const char * end, double & result)
 {
-    bool r = qi::phrase_parse(iter,end,DOUBLE,ascii::space,result);
+    ascii::space_type space;
+    bool r = qi::phrase_parse(iter,end,DOUBLE,space,result);
     return r && (iter == end);
 }
 
 bool string2float(std::string const& value, float & result)
 {
+    ascii::space_type space;
     std::string::const_iterator str_beg = value.begin();
     std::string::const_iterator str_end = value.end();
-    bool r = qi::phrase_parse(str_beg,str_end,FLOAT,ascii::space,result);
+    bool r = qi::phrase_parse(str_beg,str_end,FLOAT,space,result);
     return r && (str_beg == str_end);
 }
 
 bool string2float(const char * iter, const char * end, float & result)
 {
-    bool r = qi::phrase_parse(iter,end,FLOAT,ascii::space,result);
+    ascii::space_type space;
+    bool r = qi::phrase_parse(iter,end,FLOAT,space,result);
     return r && (iter == end);
 }
 
--- a/src/expression.cpp
+++ b/src/expression.cpp
@@ -45,9 +45,10 @@
                                 mapnik::expression_grammar<std::string::const_iterator> const& g)
 {
     expr_node node;
+    boost::spirit::standard_wide::space_type space;
     std::string::const_iterator itr = str.begin();
     std::string::const_iterator end = str.end();
-    bool r = boost::spirit::qi::phrase_parse(itr, end, g, boost::spirit::standard_wide::space, node);
+    bool r = boost::spirit::qi::phrase_parse(itr, end, g, space, node);
     if (r && itr == end)
     {
         return boost::make_shared<expr_node>(node);
--- a/src/feature_style_processor.cpp
+++ b/src/feature_style_processor.cpp
@@ -21,6 +21,7 @@
  *****************************************************************************/
 
 // mapnik
+
 #include <mapnik/feature_style_processor_impl.hpp>
 #include <mapnik/agg_renderer.hpp>
 #include <mapnik/graphics.hpp>
--- a/src/image_filter_grammar.cpp
+++ b/src/image_filter_grammar.cpp
@@ -38,28 +38,26 @@
 image_filter_grammar<Iterator,ContType>::image_filter_grammar()
     : image_filter_grammar::base_type(start)
 {
-    using qi::lit;
-    using qi::_val;
-    using qi::_1;
-    using qi::_a;
-    using qi::_b;
-    using qi::_c;
-    using qi::_d;
-    using qi::_e;
-    using qi::_f;
-    using qi::_g;
-    using qi::_h;
-    using qi::_r1;
-    using qi::eps;
-    using qi::char_;
-    using qi::lexeme;
-    using qi::double_;
-    using boost::spirit::ascii::string;
+    qi::lit_type lit;
+    qi::_val_type _val;
+    qi::_1_type _1;
+    qi::_a_type _a;
+    qi::_b_type _b;
+    qi::_c_type _c;
+    qi::_d_type _d;
+    qi::_e_type _e;
+    qi::_f_type _f;
+    qi::_g_type _g;
+    qi::_h_type _h;
+    qi::_r1_type _r1;
+    qi::eps_type eps;
+    qi::char_type char_;
+    qi::double_type double_;
     using phoenix::push_back;
     using phoenix::construct;
     using phoenix::at_c;
 #if BOOST_VERSION >= 104700
-    using qi::no_skip;
+    qi::no_skip_type no_skip;
     start = -(filter % no_skip[*char_(", ")])
         ;
 #else
--- a/src/image_filter_types.cpp
+++ b/src/image_filter_types.cpp
@@ -58,7 +58,7 @@
 
 bool generate_image_filters(std::back_insert_iterator<std::string>& sink, std::vector<filter_type> const& filters)
 {
-    using boost::spirit::karma::stream;
+    boost::spirit::karma::stream_type stream;
     using boost::spirit::karma::generate;
     bool r = generate(sink, stream % ' ', filters);
     return r;
@@ -70,9 +70,10 @@
     std::string::const_iterator end = filters.end();
     mapnik::image_filter_grammar<std::string::const_iterator,
                                  std::vector<mapnik::filter::filter_type> > filter_grammar;
+    boost::spirit::qi::ascii::space_type space;
     bool r = boost::spirit::qi::phrase_parse(itr,end,
                                              filter_grammar,
-                                             boost::spirit::qi::ascii::space,
+                                             space,
                                              image_filters);
     return r && itr==end;
 }
--- a/src/json/feature_collection_parser.cpp
+++ b/src/json/feature_collection_parser.cpp
@@ -55,7 +55,8 @@
     {
 #if BOOST_VERSION >= 104700
         using namespace boost::spirit;
-        return qi::phrase_parse(first, last, *grammar_, standard_wide::space, features);
+        standard_wide::space_type space;
+        return qi::phrase_parse(first, last, *grammar_, space, features);
 #else
         std::ostringstream s;
         s << BOOST_VERSION/100000 << "." << BOOST_VERSION/100 % 1000  << "." << BOOST_VERSION % 100;
--- a/src/json/feature_grammar.cpp
+++ b/src/json/feature_grammar.cpp
@@ -37,30 +37,26 @@
     : feature_grammar::base_type(feature,"feature"),
       put_property_(put_property(tr))
 {
-    using qi::lit;
-    using qi::long_long;
-    using qi::double_;
+    qi::lit_type lit;
+    qi::long_long_type long_long;
+    qi::double_type double_;
 #if BOOST_VERSION > 104200
-    using qi::no_skip;
+    qi::no_skip_type no_skip;
 #else
-    using qi::lexeme;
+    qi::lexeme_type lexeme;
 #endif
-    using standard_wide::char_;
-    using qi::_val;
-    using qi::_1;
-    using qi::_2;
-    using qi::_3;
-    using qi::_4;
-    using qi::_a;
-    using qi::_b;
-    using qi::_r1;
-    using qi::_r2;
+    standard_wide::char_type char_;
+    qi::_val_type _val;
+    qi::_1_type _1;
+    qi::_2_type _2;
+    qi::_3_type _3;
+    qi::_4_type _4;
+    qi::_a_type _a;
+    qi::_r1_type _r1;
+    qi::eps_type eps;
+
     using qi::fail;
     using qi::on_error;
-    using qi::_pass;
-    using qi::eps;
-    using qi::raw;
-
     using phoenix::new_;
     using phoenix::push_back;
     using phoenix::construct;
--- a/src/json/geometry_grammar.cpp
+++ b/src/json/geometry_grammar.cpp
@@ -41,20 +41,18 @@
     : geometry_grammar::base_type(geometry,"geometry")
 {
 
-    using qi::lit;
-    using qi::int_;
-    using qi::double_;
-    using qi::_val;
-    using qi::_1;
-    using qi::_2;
-    using qi::_3;
-    using qi::_4;
-    using qi::_a;
-    using qi::_b;
-    using qi::_r1;
-    using qi::_r2;
-    using qi::eps;
-    using qi::_pass;
+    qi::lit_type lit;
+    qi::int_type int_;
+    qi::double_type double_;
+    qi::_1_type _1;
+    qi::_2_type _2;
+    qi::_3_type _3;
+    qi::_4_type _4;
+    qi::_a_type _a;
+    qi::_r1_type _r1;
+    qi::_r2_type _r2;
+    qi::eps_type eps;
+    qi::_pass_type _pass;
     using qi::fail;
     using qi::on_error;
     using boost::phoenix::new_;
--- a/src/json/geometry_parser.cpp
+++ b/src/json/geometry_parser.cpp
@@ -50,7 +50,8 @@
 {
 #if BOOST_VERSION >= 104700
     using namespace boost::spirit;
-    return qi::phrase_parse(first, last, (*grammar_)(boost::phoenix::ref(path)), standard_wide::space);
+    standard_wide::space_type space;
+    return qi::phrase_parse(first, last, (*grammar_)(boost::phoenix::ref(path)), space);
 #else
     std::ostringstream s;
     s << BOOST_VERSION/100000 << "." << BOOST_VERSION/100 % 1000  << "." << BOOST_VERSION % 100;
--- a/src/load_map.cpp
+++ b/src/load_map.cpp
@@ -451,9 +451,10 @@
             std::string filter_str = *direct_filters;
             std::string::const_iterator itr = filter_str.begin();
             std::string::const_iterator end = filter_str.end();
+            boost::spirit::qi::ascii::space_type space;
             bool result = boost::spirit::qi::phrase_parse(itr,end,
                                                           sty.get_tree().image_filters_grammar,
-                                                          boost::spirit::qi::ascii::space,
+                                                          space,
                                                           style.direct_image_filters());
             if (!result || itr!=end)
             {
--- a/src/parse_path.cpp
+++ b/src/parse_path.cpp
@@ -48,11 +48,11 @@
 path_expression_ptr parse_path(std::string const& str,
                                path_expression_grammar<std::string::const_iterator> const& g)
 {
-    path_expression path;  
-    
+    path_expression path;
+    boost::spirit::standard_wide::space_type space;
     std::string::const_iterator itr = str.begin();
     std::string::const_iterator end = str.end();
-    bool r = qi::phrase_parse(itr, end, g, boost::spirit::standard_wide::space, path);
+    bool r = qi::phrase_parse(itr, end, g, space, path);
     if (r  && itr == end)
     {
         return boost::make_shared<path_expression>(path); //path;
--- a/src/path_expression_grammar.cpp
+++ b/src/path_expression_grammar.cpp
@@ -36,13 +36,13 @@
 path_expression_grammar<Iterator>::path_expression_grammar()
     : path_expression_grammar::base_type(expr)
 {
-    using boost::phoenix::construct;
-    using standard_wide::char_;
-    using qi::_1;
-    using qi::_val;
-    using qi::lit;
-    using qi::lexeme;
+    standard_wide::char_type char_;
+    qi::_1_type _1;
+    qi::_val_type _val;
+    qi::lit_type lit;
+    qi::lexeme_type lexeme;
     using phoenix::push_back;
+    using boost::phoenix::construct;
     
     expr =
         * (
--- a/src/svg/output/svg_generator.cpp
+++ b/src/svg/output/svg_generator.cpp
@@ -41,6 +41,7 @@
     template <typename OutputIterator>
     void svg_generator<OutputIterator>::generate_header()
     {
+        karma::lit_type lit;
         karma::generate(output_iterator_, lit("<?xml version=\"1.0\" standalone=\"no\"?>\n"));
         karma::generate(output_iterator_, lit("<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n"));
     }
@@ -49,12 +50,14 @@
     void svg_generator<OutputIterator>::generate_opening_root(root_output_attributes const& root_attributes)
     {
         root_attributes_grammar attributes_grammar;
+        karma::lit_type lit;
         karma::generate(output_iterator_, lit("<svg ") << attributes_grammar << lit(">\n"), root_attributes);
     }
 
     template <typename OutputIterator>
     void svg_generator<OutputIterator>::generate_closing_root()
     {
+        karma::lit_type lit;
         karma::generate(output_iterator_, lit("</svg>"));
     }
 
@@ -62,6 +65,7 @@
     void svg_generator<OutputIterator>::generate_rect(rect_output_attributes const& rect_attributes)
     {
         rect_attributes_grammar attributes_grammar;
+        karma::lit_type lit;
         karma::generate(output_iterator_, lit("<rect ") << attributes_grammar << lit("/>\n"), rect_attributes);
     }
 
--- a/src/svg/svg_parser.cpp
+++ b/src/svg/svg_parser.cpp
@@ -81,10 +81,12 @@
     key_value_sequence_ordered()
         : key_value_sequence_ordered::base_type(query)
     {
-        query =  pair >> *( qi::lit(';') >> pair);
+        qi::lit_type lit;
+        qi::char_type char_;
+        query =  pair >> *( lit(';') >> pair);
         pair  =  key >> -(':' >> value);
-        key   =  qi::char_("a-zA-Z_") >> *qi::char_("a-zA-Z_0-9-");
-        value = +(qi::char_ - qi::lit(';'));
+        key   =  char_("a-zA-Z_") >> *char_("a-zA-Z_0-9-");
+        value = +(char_ - lit(';'));
     }
 
     qi::rule<Iterator, pairs_type(), SkipType> query;
@@ -109,6 +111,7 @@
 double parse_double(const char* str)
 {
     using namespace boost::spirit::qi;
+    qi::double_type double_;
     double val = 0.0;
     parse(str, str + std::strlen(str),double_,val);
     return val;
@@ -122,7 +125,9 @@
 {
     using namespace boost::spirit::qi;
     using boost::phoenix::ref;
-    using qi::_1;
+    qi::_1_type _1;
+    qi::double_type double_;
+    qi::char_type char_;
 
     double val = 0.0;
     char unit='\0';
--- a/src/transform_expression_grammar.cpp
+++ b/src/transform_expression_grammar.cpp
@@ -39,14 +39,17 @@
         : transform_expression_grammar::base_type(start)
 {
     using boost::phoenix::construct;
-    using qi::_a; using qi::_1; using qi::_4;
-    using qi::_b; using qi::_2; using qi::_5;
-    using qi::_c; using qi::_3; using qi::_6;
-    using qi::_val;
-    using qi::char_;
-    using qi::double_;
-    using qi::lit;
-    using qi::no_case;
+    qi::_1_type _1;
+    qi::_4_type _4;
+    qi::_2_type _2;
+    qi::_5_type _5;
+    qi::_3_type _3;
+    qi::_6_type _6;
+    qi::_val_type _val;
+    qi::char_type char_;
+    qi::double_type double_;
+    qi::lit_type lit;
+    qi::no_case_type no_case;
 
     // [http://www.w3.org/TR/SVG/coords.html#TransformAttribute]
 
@@ -56,10 +59,10 @@
     // separated by whitespace and/or a comma.
 
 #if BOOST_VERSION > 104200
-    using qi::no_skip;
+    qi::no_skip_type no_skip;
     start = transform_ % no_skip[char_(", ")] ;
 #else
-    using qi::lexeme;
+    qi::lexeme_type lexeme;
     start = transform_ % lexeme[char_(", ")] ;
 #endif
 
--- a/src/wkt/wkt_factory.cpp
+++ b/src/wkt/wkt_factory.cpp
@@ -44,9 +44,10 @@
 bool wkt_parser::parse(std::string const& wkt, boost::ptr_vector<geometry_type> & paths)
 {
     using namespace boost::spirit;
+    ascii::space_type space;
     iterator_type first = wkt.begin();
     iterator_type last =  wkt.end();
-    return qi::phrase_parse(first, last, *grammar_, ascii::space, paths);
+    return qi::phrase_parse(first, last, *grammar_, space, paths);
 }
 #endif
 
--- a/src/wkt/wkt_generator.cpp
+++ b/src/wkt/wkt_generator.cpp
@@ -58,35 +58,35 @@
 wkt_generator<OutputIterator, Geometry>::wkt_generator(bool single)
     : wkt_generator::base_type(wkt)
 {
-    using boost::spirit::karma::uint_;
-    using boost::spirit::karma::_val;
-    using boost::spirit::karma::_1;
-    using boost::spirit::karma::lit;
-    using boost::spirit::karma::_a;
-    using boost::spirit::karma::_b;
-    using boost::spirit::karma::_c;
-    using boost::spirit::karma::_r1;
-    using boost::spirit::karma::eps;
-    using boost::spirit::karma::string;
+    boost::spirit::karma::uint_type uint_;
+    boost::spirit::karma::_val_type _val;
+    boost::spirit::karma::_1_type _1;
+    boost::spirit::karma::lit_type lit;
+    boost::spirit::karma::_a_type _a;
+    boost::spirit::karma::_b_type _b;
+    boost::spirit::karma::_c_type _c;
+    boost::spirit::karma::_r1_type _r1;
+    boost::spirit::karma::eps_type eps;
+    boost::spirit::karma::string_type kstring;
 
     wkt = point | linestring | polygon
         ;
 
     point = &uint_(mapnik::Point)[_1 = _type(_val)]
-        << string[ phoenix::if_ (single) [_1 = "Point("]
+        << kstring[ phoenix::if_ (single) [_1 = "Point("]
                    .else_[_1 = "("]]
         << point_coord [_1 = _first(_val)] << lit(')')
         ;
 
     linestring = &uint_(mapnik::LineString)[_1 = _type(_val)]
-        << string[ phoenix::if_ (single) [_1 = "LineString("]
+        << kstring[ phoenix::if_ (single) [_1 = "LineString("]
                    .else_[_1 = "("]]
         << coords
         << lit(')')
         ;
 
     polygon = &uint_(mapnik::Polygon)[_1 = _type(_val)]
-        << string[ phoenix::if_ (single) [_1 = "Polygon("]
+        << kstring[ phoenix::if_ (single) [_1 = "Polygon("]
                    .else_[_1 = "("]]
         << coords2
         << lit("))")
@@ -97,7 +97,7 @@
 
     polygon_coord %= ( &uint_(mapnik::SEG_MOVETO)
                        << eps[_r1 += 1][_a  = _x(_val)][ _b = _y(_val)]
-                       << string[ if_ (_r1 > 1) [_1 = "),("]
+                       << kstring[ if_ (_r1 > 1) [_1 = "),("]
                                   .else_[_1 = "("]]
                        |
                        &uint_(mapnik::SEG_LINETO)
@@ -119,11 +119,11 @@
 wkt_multi_generator<OutputIterator, GeometryContainer>::wkt_multi_generator()
     : wkt_multi_generator::base_type(wkt)
 {
-    using boost::spirit::karma::lit;
-    using boost::spirit::karma::eps;
-    using boost::spirit::karma::_val;
-    using boost::spirit::karma::_1;
-    using boost::spirit::karma::_a;
+    boost::spirit::karma::lit_type lit;
+    boost::spirit::karma::eps_type eps;
+    boost::spirit::karma::_val_type _val;
+    boost::spirit::karma::_1_type _1;
+    boost::spirit::karma::_a_type _a;
 
     geometry_types.add
         (mapnik::Point,"Point")
--- a/include/mapnik/css_color_grammar.hpp
+++ b/include/mapnik/css_color_grammar.hpp
@@ -453,13 +453,13 @@
         : css_color_grammar::base_type(css_color)
 
     {
-        using qi::lit;
-        using qi::_val;
-        using qi::double_;
-        using qi::_1;
-        using qi::_a;
-        using qi::_b;
-        using qi::_c;
+        qi::lit_type lit;
+        qi::_val_type _val;
+        qi::double_type double_;
+        qi::_1_type _1;
+        qi::_a_type _a;
+        qi::_b_type _b;
+        qi::_c_type _c;
         using ascii::no_case;
         using phoenix::at_c;
 
--- a/include/mapnik/css_color_grammar_impl.hpp
+++ b/include/mapnik/css_color_grammar_impl.hpp
@@ -38,14 +38,14 @@
     : css_color_grammar::base_type(css_color)
 
 {
-    using qi::lit;
-    using qi::_val;
-    using qi::double_;
-    using qi::_1;
-    using qi::_a;
-    using qi::_b;
-    using qi::_c;
-    using ascii::no_case;
+    qi::lit_type lit;
+    qi::_val_type _val;
+    qi::double_type double_;
+    qi::_1_type _1;
+    qi::_a_type _a;
+    qi::_b_type _b;
+    qi::_c_type _c;
+    ascii::no_case_type no_case;
     using phoenix::at_c;
 
     css_color %= rgba_color
--- a/include/mapnik/expression_grammar_impl.hpp
+++ b/include/mapnik/expression_grammar_impl.hpp
@@ -72,21 +72,20 @@
       regex_replace_(regex_replace_impl(tr))
 {
     using boost::phoenix::construct;
-    using qi::_1;
-    using qi::_a;
-    using qi::_b;
-    using qi::_r1;
+    qi::_1_type _1;
+    qi::_a_type _a;
+    qi::_b_type _b;
+    qi::_r1_type _r1;
 #if BOOST_VERSION > 104200
-    using qi::no_skip;
+    qi::no_skip_type no_skip;
 #endif
-    using qi::lexeme;
-    using qi::_val;
-    using qi::lit;
-    using qi::double_;
-    using qi::hex;
-    using qi::omit;
-    using standard_wide::char_;
-    using standard_wide::no_case;
+    qi::_val_type _val;
+    qi::lit_type lit;
+    qi::double_type double_;
+    qi::hex_type hex;
+    qi::omit_type omit;
+    standard_wide::char_type char_;
+    standard_wide::no_case_type no_case;
 
     expr = logical_expr.alias();
 
--- a/include/mapnik/json/feature_collection_grammar.hpp
+++ b/include/mapnik/json/feature_collection_grammar.hpp
@@ -42,14 +42,14 @@
 struct generate_id
 {
     typedef int result_type;
-    
+
     generate_id(int start)
         : id_(start) {}
-    
+
     int operator() () const
     {
         return id_++;
-    }    
+    }
     mutable int id_;
 };
 
@@ -63,12 +63,14 @@
           feature_g(tr),
           generate_id_(1)
     {
-        using qi::lit;
-        using qi::eps;
-        using qi::_a;
-        using qi::_b;
-        using qi::_val;
-        using qi::_r1;
+        qi::lit_type lit;
+        qi::eps_type eps;
+        qi::_4_type _4;
+        qi::_3_type _2;
+        qi::_2_type _3;
+        qi::_a_type _a;
+        qi::_val_type _val;
+        qi::_r1_type _r1;
         using phoenix::push_back;
         using phoenix::construct;
         using phoenix::new_;
@@ -76,7 +78,7 @@
 
         feature_collection = lit('{') >> (type | features) % lit(",") >> lit('}')
             ;
-        
+
         type = lit("\"type\"") > lit(":") > lit("\"FeatureCollection\"")
             ;
 
@@ -86,29 +88,29 @@
             > -(feature(_val) % lit(','))
             > lit(']')
             ;
-        
+
         feature = eps[_a = phoenix::construct<mapnik::feature_ptr>(new_<mapnik::feature_impl>(ctx_,generate_id_()))]
             >> feature_g(*_a)[push_back(_r1,_a)]
             ;
-        
+
         type.name("type");
         features.name("features");
         feature.name("feature");
         feature_g.name("feature-grammar");
-        
+
         qi::on_error<qi::fail>
             (
                 feature_collection
                 , std::clog
                 << phoenix::val("Error parsing GeoJSON ")
-                << qi::_4                       
+                << _4
                 << phoenix::val(" here: \"")
-                << construct<std::string>(qi::_3, qi::_2) 
+                << construct<std::string>(_3, _2)
                 << phoenix::val("\"")
                 << std::endl
                 );
     }
-    
+
     context_ptr ctx_;
     qi::rule<Iterator, std::vector<feature_ptr>(), space_type> feature_collection; // START
     qi::rule<Iterator, space_type> type;
--- a/include/mapnik/json/feature_generator_grammar.hpp
+++ b/include/mapnik/json/feature_generator_grammar.hpp
@@ -146,8 +146,11 @@
     escaped_string()
         : escaped_string::base_type(esc_str)
     {
-        using boost::spirit::karma::maxwidth;
-        using boost::spirit::karma::right_align;
+        karma::lit_type lit;
+        karma::_r1_type _r1;
+        karma::hex_type hex;
+        karma::right_align_type right_align;
+        karma::print_type kprint;
 
         esc_char.add
             ('"', "\\\"")
@@ -159,11 +162,11 @@
             ('\t', "\\t")
             ;
 
-        esc_str =   karma::lit(karma::_r1)
+        esc_str =   lit(_r1)
             << *(esc_char
-                 | karma::print
-                 | "\\u" << right_align(4,karma::lit('0'))[karma::hex])
-            <<  karma::lit(karma::_r1)
+                 | kprint
+                 | "\\u" << right_align(4,lit('0'))[hex])
+            <<  lit(_r1)
             ;
     }
 
@@ -184,17 +187,15 @@
         , quote_("\"")
 
     {
-        using boost::spirit::karma::lit;
-        using boost::spirit::karma::uint_;
-        using boost::spirit::karma::bool_;
-        //using boost::spirit::karma::int_;
-        //using boost::spirit::karma::long_long;
-        using boost::spirit::karma::double_;
-        using boost::spirit::karma::_val;
-        using boost::spirit::karma::_1;
-        using boost::spirit::karma::_r1;
-        using boost::spirit::karma::string;
-        using boost::spirit::karma::eps;
+        boost::spirit::karma::lit_type lit;
+        boost::spirit::karma::uint_type uint_;
+        boost::spirit::karma::bool_type bool_;
+        boost::spirit::karma::double_type double_;
+        boost::spirit::karma::_val_type _val;
+        boost::spirit::karma::_1_type _1;
+        boost::spirit::karma::_r1_type _r1;
+        boost::spirit::karma::string_type kstring;
+        boost::spirit::karma::eps_type eps;
 
         feature = lit("{\"type\":\"Feature\",\"id\":")
             << uint_[_1 = id_(_val)]
@@ -209,7 +210,7 @@
             ;
 
         pair = lit('"')
-            << string[_1 = phoenix::at_c<0>(_val)] << lit('"')
+            << kstring[_1 = phoenix::at_c<0>(_val)] << lit('"')
             << lit(':')
             << value(phoenix::at_c<1>(_val))
             ;
@@ -217,7 +218,7 @@
         value = (value_null_| bool_ | int__ | double_ | ustring)[_1 = value_base_(_r1)]
             ;
 
-        value_null_ = string[_1 = "null"]
+        value_null_ = kstring[_1 = "null"]
             ;
 
         ustring = escaped_string_(quote_.c_str())[_1 = utf8_(_val)]
--- a/include/mapnik/json/geometry_generator_grammar.hpp
+++ b/include/mapnik/json/geometry_generator_grammar.hpp
@@ -152,13 +152,14 @@
     geometry_generator_grammar()
         : geometry_generator_grammar::base_type(coordinates)
     {
-        using boost::spirit::karma::uint_;
-        using boost::spirit::karma::_val;
-        using boost::spirit::karma::_1;
-        using boost::spirit::karma::lit;
-        using boost::spirit::karma::_a;
-        using boost::spirit::karma::_r1;
-        using boost::spirit::karma::eps;
+        boost::spirit::karma::uint_type uint_;
+        boost::spirit::karma::_val_type _val;
+        boost::spirit::karma::_1_type _1;
+        boost::spirit::karma::lit_type lit;
+        boost::spirit::karma::_a_type _a;
+        boost::spirit::karma::_r1_type _r1;
+        boost::spirit::karma::eps_type eps;
+        boost::spirit::karma::string_type kstring;
 
         coordinates =  point | linestring | polygon
             ;
@@ -186,7 +187,7 @@
             ;
 
         polygon_coord %= ( &uint_(mapnik::SEG_MOVETO) << eps[_r1 += 1]
-                           << karma::string[ if_ (_r1 > 1) [_1 = "],["]
+                           << kstring[ if_ (_r1 > 1) [_1 = "],["]
                                       .else_[_1 = '[' ]] | &uint_ << lit(','))
             << lit('[') << coord_type
             << lit(',')
@@ -229,12 +230,13 @@
     multi_geometry_generator_grammar()
         : multi_geometry_generator_grammar::base_type(start)
     {
-        using boost::spirit::karma::lit;
-        using boost::spirit::karma::eps;
-        using boost::spirit::karma::_val;
-        using boost::spirit::karma::_1;
-        using boost::spirit::karma::_a;
-        using boost::spirit::karma::_r1;
+        boost::spirit::karma::_val_type _val;
+        boost::spirit::karma::_1_type _1;
+        boost::spirit::karma::lit_type lit;
+        boost::spirit::karma::_a_type _a;
+        boost::spirit::karma::_r1_type _r1;
+        boost::spirit::karma::eps_type eps;
+        boost::spirit::karma::string_type kstring;
 
         geometry_types.add
             (mapnik::Point,"\"Point\"")
@@ -258,9 +260,9 @@
         geometry = (lit("{\"type\":")
                     << geometry_types[_1 = phoenix::at_c<0>(_a)][_a = _multi_type(_val)]
                     << lit(",\"coordinates\":")
-                    << karma::string[ if_ (phoenix::at_c<0>(_a) > 3) [_1 = '[']]
+                    << kstring[ if_ (phoenix::at_c<0>(_a) > 3) [_1 = '[']]
                     << coordinates
-                    << karma::string[ if_ (phoenix::at_c<0>(_a) > 3) [_1 = ']']]
+                    << kstring[ if_ (phoenix::at_c<0>(_a) > 3) [_1 = ']']]
                     << lit('}')) | lit("null")
             ;
 
--- a/include/mapnik/svg/output/svg_generator.hpp
+++ b/include/mapnik/svg/output/svg_generator.hpp
@@ -23,6 +23,14 @@
 #ifndef MAPNIK_SVG_GENERATOR_HPP
 #define MAPNIK_SVG_GENERATOR_HPP
 
+// FIXME: workaround incompatibility of karma with -DBOOST_SPIRIT_NO_PREDEFINED_TERMINALS=1
+/*
+boost/spirit/repository/home/karma/directive/confix.hpp:49:23: error: no member named
+      'confix' in namespace 'boost::spirit::repository'
+    using repository::confix;
+*/
+#undef BOOST_SPIRIT_NO_PREDEFINED_TERMINALS
+
 // mapnik
 #include <mapnik/ctrans.hpp>
 #include <mapnik/color.hpp>
@@ -60,6 +68,7 @@
         template <typename PathType>
         void generate_path(PathType const& path, path_output_attributes const& path_attributes)
         {
+            karma::lit_type lit;
             util::svg_generator<OutputIterator,PathType> svg_path_grammer;
             karma::generate(output_iterator_, lit("<path ") << svg_path_grammer, path);
             path_attributes_grammar attributes_grammar;
--- a/include/mapnik/svg/output/svg_output_grammars.hpp
+++ b/include/mapnik/svg/output/svg_output_grammars.hpp
@@ -100,18 +100,19 @@
     explicit svg_path_attributes_grammar()
         : svg_path_attributes_grammar::base_type(svg_path_attributes)
     {
-        using karma::double_;
-        using karma::string;
-        using repository::confix;
+        karma::lit_type lit;
+        karma::double_type double_;
+        karma::string_type kstring;
+        repository::confix_type confix;
 
         svg_path_attributes =
-            lit("fill=") << confix('"', '"')[string]
+            lit("fill=") << confix('"', '"')[kstring]
                          << lit(" fill-opacity=") << confix('"', '"')[double_]
-                         << lit(" stroke=") << confix('"', '"')[string]
+                         << lit(" stroke=") << confix('"', '"')[kstring]
                          << lit(" stroke-opacity=") << confix('"', '"')[double_]
                          << lit(" stroke-width=") << confix('"', '"')[double_ << lit("px")]
-                         << lit(" stroke-linecap=") << confix('"', '"')[string]
-                         << lit(" stroke-linejoin=") << confix('"', '"')[string]
+                         << lit(" stroke-linecap=") << confix('"', '"')[kstring]
+                         << lit(" stroke-linejoin=") << confix('"', '"')[kstring]
                          << lit(" stroke-dashoffset=") << confix('"', '"')[double_ << lit("px")];
     }
 
@@ -124,8 +125,9 @@
     explicit svg_path_dash_array_grammar()
         : svg_path_dash_array_grammar::base_type(svg_path_dash_array)
     {
-        using karma::double_;
-        using repository::confix;
+        karma::double_type double_;
+        karma::lit_type lit;
+        repository::confix_type confix;
 
         svg_path_dash_array =
             lit("stroke-dasharray=")
@@ -142,16 +144,17 @@
     explicit svg_rect_attributes_grammar()
         : svg_rect_attributes_grammar::base_type(svg_rect_attributes)
     {
-        using karma::int_;
-        using karma::string;
-        using repository::confix;
+        karma::lit_type lit;
+        karma::int_type int_;
+        karma::string_type kstring;
+        repository::confix_type confix;
 
         svg_rect_attributes =
             lit("x=") << confix('"', '"')[int_]
                       << lit(" y=") << confix('"', '"')[int_]
                       << lit(" width=") << confix('"', '"')[int_ << lit("px")]
                       << lit(" height=") << confix('"', '"')[int_ << lit("px")]
-                      << lit(" fill=") << confix('"', '"')[string];
+                      << lit(" fill=") << confix('"', '"')[kstring];
     }
 
     karma::rule<OutputIterator, mapnik::svg::rect_output_attributes()> svg_rect_attributes;
@@ -163,16 +166,17 @@
     explicit svg_root_attributes_grammar()
         : svg_root_attributes_grammar::base_type(svg_root_attributes)
     {
-        using karma::int_;
-        using karma::string;
-        using karma::double_;
-        using repository::confix;
+        karma::lit_type lit;
+        karma::int_type int_;
+        karma::string_type kstring;
+        karma::double_type double_;
+        repository::confix_type confix;
 
         svg_root_attributes =
             lit("width=") << confix('"', '"')[int_ << lit("px")]
                           << lit(" height=") << confix('"', '"')[int_ << lit("px")]
                           << " version=" << confix('"', '"')[double_]
-                          << " xmlns=" << confix('"', '"')[string];
+                          << " xmlns=" << confix('"', '"')[kstring];
     }
 
     karma::rule<OutputIterator, mapnik::svg::root_output_attributes()> svg_root_attributes;
--- a/include/mapnik/svg/output/svg_renderer.hpp
+++ b/include/mapnik/svg/output/svg_renderer.hpp
@@ -24,6 +24,7 @@
 #define MAPNIK_SVG_RENDERER_HPP
 
 // mapnik
+#undef BOOST_SPIRIT_NO_PREDEFINED_TERMINALS
 #include <mapnik/config.hpp>
 #include <mapnik/feature_style_processor.hpp>
 #include <mapnik/font_engine_freetype.hpp>
--- a/include/mapnik/svg/svg_path_grammar.hpp
+++ b/include/mapnik/svg/svg_path_grammar.hpp
@@ -53,16 +53,16 @@
               arc_to_(arc_to<PathType>(path)),
               close_(close<PathType>(path))
         {
-            using qi::_1;
-            using qi::_2;
-            using qi::_3;
-            using qi::_4;
-            using qi::_5;
-            using qi::_a;
-            using qi::lit;
-            using qi::double_;
-            using qi::int_;
-            using qi::no_case;
+            qi::_1_type _1;
+            qi::_2_type _2;
+            qi::_3_type _3;
+            qi::_4_type _4;
+            qi::_5_type _5;
+            qi::_a_type _a;
+            qi::lit_type lit;
+            qi::double_type double_;
+            qi::int_type int_;
+            qi::no_case_type no_case;
 
             start = +cmd;
             cmd = M  >> *drawto_cmd;
--- a/include/mapnik/svg/svg_points_grammar.hpp
+++ b/include/mapnik/svg/svg_points_grammar.hpp
@@ -45,9 +45,9 @@
               line_to_(line_to<PathType>(path)),
               close_(close<PathType>(path))
         {
-            using qi::_1;
-            using qi::_2;
-            using qi::double_;
+            qi::_1_type _1;
+            qi::lit_type lit;
+            qi::double_type double_;
 
             start = coord[move_to_(_1,false)] // move_to
                 >> *(-lit(',') >> coord [ line_to_(_1,false) ] ); // *line_to
--- a/include/mapnik/svg/svg_transform_grammar.hpp
+++ b/include/mapnik/svg/svg_transform_grammar.hpp
@@ -187,18 +187,18 @@
               scale_action(process_scale<TransformType>(tr)),
               skew_action(process_skew<TransformType>(tr))
         {
-            using qi::_1;
-            using qi::_2;
-            using qi::_3;
-            using qi::_4;
-            using qi::_5;
-            using qi::_6;
-            using qi::_a;
-            using qi::_b;
-            using qi::_c;
-            using qi::_val;
-            using qi::double_;
-            using qi::no_case;
+            qi::_1_type _1;
+            qi::_2_type _2;
+            qi::_3_type _3;
+            qi::_4_type _4;
+            qi::_5_type _5;
+            qi::_6_type _6;
+            qi::_a_type _a;
+            qi::_b_type _b;
+            qi::_c_type _c;
+            qi::lit_type lit;
+            qi::double_type double_;
+            qi::no_case_type no_case;
 
             start =  +transform_ ;
 
--- a/include/mapnik/util/dasharray_parser.hpp
+++ b/include/mapnik/util/dasharray_parser.hpp
@@ -33,22 +33,22 @@
 template <typename Iterator>
 bool parse_dasharray(Iterator first, Iterator last, std::vector<double>& dasharray)
 {
-    using qi::double_;
-    using qi::phrase_parse;
-    using qi::_1;
-    using qi::lit;
-    using qi::char_;
+    qi::double_type double_;
+    qi::_1_type _1;
+    qi::lit_type lit;
+    qi::char_type char_;
+    qi::ascii::space_type space;
 #if BOOST_VERSION > 104200
-    using qi::no_skip;
+    qi::no_skip_type no_skip;
 #else
-    using qi::lexeme;
+    qi::lexeme_type lexeme;
 #endif
     using phoenix::push_back;
-    // SVG 
+    // SVG
     // dasharray ::= (length | percentage) (comma-wsp dasharray)?
     // no support for 'percentage' as viewport is unknown at load_map
-    // 
-    bool r = phrase_parse(first, last,
+    //
+    bool r = qi::phrase_parse(first, last,
                           (double_[push_back(phoenix::ref(dasharray), _1)] %
 #if BOOST_VERSION > 104200
                           no_skip[char_(", ")]
@@ -56,11 +56,11 @@
                           lexeme[char_(", ")]
 #endif
                           | lit("none")),
-                          qi::ascii::space);
-    
-    if (first != last) 
+                          space);
+
+    if (first != last)
         return false;
-    
+
     return r;
 }
 
--- a/include/mapnik/util/geometry_svg_generator.hpp
+++ b/include/mapnik/util/geometry_svg_generator.hpp
@@ -141,11 +141,12 @@
         svg_generator()
             : svg_generator::base_type(svg)
         {
-            using boost::spirit::karma::uint_;
-            using boost::spirit::karma::_val;
-            using boost::spirit::karma::_1;
-            using boost::spirit::karma::lit;
-            using boost::spirit::karma::_a;
+            boost::spirit::karma::uint_type uint_;
+            boost::spirit::karma::_val_type _val;
+            boost::spirit::karma::_1_type _1;
+            boost::spirit::karma::lit_type lit;
+            boost::spirit::karma::_a_type _a;
+            boost::spirit::karma::string_type kstring;
 
             svg = point | linestring | polygon
                 ;
@@ -169,7 +170,7 @@
                 ;
 
             svg_path %= ((&uint_(mapnik::SEG_MOVETO) << lit("d=\"") << lit('M')
-                          | &uint_(mapnik::SEG_LINETO) [_a +=1] << karma::string [if_(_a == 1) [_1 = "L" ] ])
+                          | &uint_(mapnik::SEG_LINETO) [_a +=1] << kstring [if_(_a == 1) [_1 = "L" ] ])
                          << lit(' ') << coordinate << lit(' ') << coordinate) % lit(' ')
                 ;
 
--- a/include/mapnik/wkt/wkt_grammar.hpp
+++ b/include/mapnik/wkt/wkt_grammar.hpp
@@ -96,9 +96,17 @@
         wkt_grammar()
             : wkt_grammar::base_type(geometry_tagged_text)
         {
-            using qi::no_case;
-            using qi::_1;
-            using qi::_2;
+            qi::_r1_type _r1;
+            qi::_r2_type _r2;
+            qi::_pass_type _pass;
+            qi::eps_type eps;
+            qi::_val_type _val;
+            qi::lit_type lit;
+            qi::no_case_type no_case;
+            qi::double_type double_;
+            qi::_1_type _1;
+            qi::_2_type _2;
+            qi::_a_type _a;
             using boost::phoenix::push_back;
 
             geometry_tagged_text = point_tagged_text
@@ -220,9 +228,8 @@
     wkt_collection_grammar()
         :  wkt_collection_grammar::base_type(start)
     {
-        using qi::_1;
-        using qi::_val;
-        using qi::no_case;
+        qi::lit_type lit;
+        qi::no_case_type no_case;
         using boost::phoenix::push_back;
         start = wkt | no_case[lit("GEOMETRYCOLLECTION")]
             >> (lit("(") >> wkt % lit(",") >> lit(")"));
--- a/plugins/input/shape/dbfile.cpp
+++ b/plugins/input/shape/dbfile.cpp
@@ -179,16 +179,24 @@
                 double val = 0.0;
                 const char *itr = record_+fields_[col].offset_;
                 const char *end = itr + fields_[col].length_;
-                if (qi::phrase_parse(itr,end,double_,ascii::space,val))
+                ascii::space_type space;
+                qi::double_type double_;
+                if (qi::phrase_parse(itr,end,double_,space,val))
+                {
                     f.put(name,val);
+                }
             }
             else
             {
                 mapnik::value_integer val = 0;
                 const char *itr = record_+fields_[col].offset_;
                 const char *end = itr + fields_[col].length_;
-                if (qi::phrase_parse(itr,end,int_,ascii::space,val))
+                ascii::space_type space;
+                qi::int_type int_;
+                if (qi::phrase_parse(itr,end,int_,space,val))
+                {
                     f.put(name,val);
+                }
             }
             break;
         }
--- a/tests/cpp_tests/svg_renderer_tests/background_color_test.cpp
+++ b/tests/cpp_tests/svg_renderer_tests/background_color_test.cpp
@@ -1,3 +1,5 @@
+#undef BOOST_SPIRIT_NO_PREDEFINED_TERMINALS
+
 #define BOOST_TEST_MODULE background_color_test
 
 /*
--- a/tests/cpp_tests/svg_renderer_tests/combined_test.cpp
+++ b/tests/cpp_tests/svg_renderer_tests/combined_test.cpp
@@ -1,3 +1,4 @@
+#undef BOOST_SPIRIT_NO_PREDEFINED_TERMINALS
 #define BOOST_TEST_MODULE combined_tests
 
 // boost.test
--- a/tests/cpp_tests/svg_renderer_tests/compilation_test.cpp
+++ b/tests/cpp_tests/svg_renderer_tests/compilation_test.cpp
@@ -1,3 +1,4 @@
+#undef BOOST_SPIRIT_NO_PREDEFINED_TERMINALS
 #define BOOST_TEST_MODULE compile_test
 
 // boost.test
--- a/tests/cpp_tests/svg_renderer_tests/file_output_test.cpp
+++ b/tests/cpp_tests/svg_renderer_tests/file_output_test.cpp
@@ -1,3 +1,4 @@
+#undef BOOST_SPIRIT_NO_PREDEFINED_TERMINALS
 #define BOOST_TEST_MODULE file_output_test
 
 /*
--- a/tests/cpp_tests/svg_renderer_tests/path_element_test.cpp
+++ b/tests/cpp_tests/svg_renderer_tests/path_element_test.cpp
@@ -1,3 +1,4 @@
+#undef BOOST_SPIRIT_NO_PREDEFINED_TERMINALS
 #define BOOST_TEST_MODULE path_element_tests
 
 // boost.test
--- a/tests/cpp_tests/svg_renderer_tests/root_element_test.cpp
+++ b/tests/cpp_tests/svg_renderer_tests/root_element_test.cpp
@@ -1,3 +1,4 @@
+#undef BOOST_SPIRIT_NO_PREDEFINED_TERMINALS
 #define BOOST_TEST_MODULE root_element_test
 
 /*
--- a/src/text_placements/simple.cpp
+++ b/src/text_placements/simple.cpp
@@ -39,9 +39,7 @@
 namespace qi = boost::spirit::qi;
 namespace phoenix = boost::phoenix;
 using phoenix::push_back;
-using boost::spirit::ascii::space;
 using phoenix::ref;
-using qi::_1;
 
 bool text_placement_info_simple::next()
 {
@@ -141,9 +139,12 @@
 
     } direction_name;
 
+    boost::spirit::ascii::space_type space;
+    qi::_1_type _1;
+    qi::float_type float_;
     std::string::iterator first = positions.begin(),  last = positions.end();
     qi::phrase_parse(first, last,
-                     (direction_name[push_back(phoenix::ref(direction_), _1)] % ',') >> *(',' >> qi::float_[push_back(phoenix::ref(text_sizes_), _1)]),
+                     (direction_name[push_back(phoenix::ref(direction_), _1)] % ',') >> *(',' >> float_[push_back(phoenix::ref(text_sizes_), _1)]),
                      space
         );
     if (first != last)
