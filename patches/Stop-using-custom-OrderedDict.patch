Description: Stop using custom OrderedDict
 OrdredDict is in the standard library for all supported Python versions
 (2.7 and 3.5+) and has improvements over the ActiveState recipe version
 of OrderedDict we have been using. Switch to importing from collections
 instead of getting it from SCons.Util (tests already did this).
 .
 At the same time, reorganize the Util.py imports - import Iterable
 from collections.abc if possible (it is deprecated to import
 it from collections, will stop working in 3.8); try getting the
 User{Dict,List,String} from collections if possible - that is, try the
 3.x way first.
Author: Mats Wichmann <mats@linux.com>
Origin: https://github.com/SCons/scons/commit/3fa7141ec7b39
Forwarded: https://github.com/mapnik/mapnik/pull/4294
Applied-Upstream: https://github.com/mapnik/mapnik/commit/7da9009e7ffffb0b9429890f6f13fee837ac320f

--- a/scons/scons-local-3.0.1/SCons/Action.py
+++ b/scons/scons-local-3.0.1/SCons/Action.py
@@ -107,6 +107,7 @@ import sys
 import subprocess
 import itertools
 import inspect
+from collections import OrderedDict
 
 import SCons.Debug
 from SCons.Debug import logInstanceCreation
@@ -1289,7 +1290,7 @@ class ListAction(ActionBase):
         return result
 
     def get_varlist(self, target, source, env, executor=None):
-        result = SCons.Util.OrderedDict()
+        result = OrderedDict()
         for act in self.list:
             for var in act.get_varlist(target, source, env, executor):
                 result[var] = True
--- a/scons/scons-local-3.0.1/SCons/Tool/javac.py
+++ b/scons/scons-local-3.0.1/SCons/Tool/javac.py
@@ -34,6 +34,7 @@ __revision__ = "src/engine/SCons/Tool/ja
 
 import os
 import os.path
+from collections import OrderedDict
 
 import SCons.Action
 import SCons.Builder
@@ -70,7 +71,7 @@ def emit_java_classes(target, source, en
         if isinstance(entry, SCons.Node.FS.File):
             slist.append(entry)
         elif isinstance(entry, SCons.Node.FS.Dir):
-            result = SCons.Util.OrderedDict()
+            result = OrderedDict()
             dirnode = entry.rdir()
             def find_java_files(arg, dirpath, filenames):
                 java_files = sorted([n for n in filenames
--- a/scons/scons-local-3.0.1/SCons/Util.py
+++ b/scons/scons-local-3.0.1/SCons/Util.py
@@ -37,21 +37,18 @@ import pprint
 PY3 = sys.version_info[0] == 3
 
 try:
+    from collections import UserDict, UserList, UserString
+except ImportError:
     from UserDict import UserDict
-except ImportError as e:
-    from collections import UserDict
-
-try:
     from UserList import UserList
-except ImportError as e:
-    from collections import UserList
-
-from collections import Iterable
+    from UserString import UserString
 
 try:
-    from UserString import UserString
-except ImportError as e:
-    from collections import UserString
+    from collections.abc import Iterable
+except ImportError:
+    from collections import Iterable
+
+from collections import OrderedDict
 
 # Don't "from types import ..." these because we need to get at the
 # types module later to look for UnicodeType.
@@ -63,7 +60,7 @@ MethodType      = types.MethodType
 FunctionType    = types.FunctionType
 
 try:
-    unicode
+    _ = type(unicode)
 except NameError:
     UnicodeType = str
 else:
@@ -1034,60 +1031,6 @@ class CLVar(UserList):
     def __str__(self):
         return ' '.join(self.data)
 
-# A dictionary that preserves the order in which items are added.
-# Submitted by David Benjamin to ActiveState's Python Cookbook web site:
-#     http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/107747
-# Including fixes/enhancements from the follow-on discussions.
-class OrderedDict(UserDict):
-    def __init__(self, dict = None):
-        self._keys = []
-        UserDict.__init__(self, dict)
-
-    def __delitem__(self, key):
-        UserDict.__delitem__(self, key)
-        self._keys.remove(key)
-
-    def __setitem__(self, key, item):
-        UserDict.__setitem__(self, key, item)
-        if key not in self._keys: self._keys.append(key)
-
-    def clear(self):
-        UserDict.clear(self)
-        self._keys = []
-
-    def copy(self):
-        dict = OrderedDict()
-        dict.update(self)
-        return dict
-
-    def items(self):
-        return list(zip(self._keys, list(self.values())))
-
-    def keys(self):
-        return self._keys[:]
-
-    def popitem(self):
-        try:
-            key = self._keys[-1]
-        except IndexError:
-            raise KeyError('dictionary is empty')
-
-        val = self[key]
-        del self[key]
-
-        return (key, val)
-
-    def setdefault(self, key, failobj = None):
-        UserDict.setdefault(self, key, failobj)
-        if key not in self._keys: self._keys.append(key)
-
-    def update(self, dict):
-        for (key, val) in dict.items():
-            self.__setitem__(key, val)
-
-    def values(self):
-        return list(map(self.get, self._keys))
-
 class Selector(OrderedDict):
     """A callable ordered dictionary that maps file suffixes to
     dictionary values.  We preserve the order in which items are added
